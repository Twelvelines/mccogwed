import java.util.*;

/* A class to generate the cogwed model for N dining cryptographers
   (see any standard reference for a description of the protocol).

   We model each cryptographer with 4 characters:
   - left coin (possible values: Head, Tail, Empty)
   - right coin (as above)
   - Paid? (Yes, No, Empty)
   - Number of utterances (Odd, eVen, Empty).
   
   For instance: HTNE is: left coin = Head, right coin = Tail, Paid = No, 
   Utterances = Empty

   The initial state is S0 = (EEEE,EEEE,...,EEEE);

*/

public class GenDinCrypt {

    public class Cryptographer {
	private String left;
	private String right;
	private String paid;
	private String utterances;

	public Cryptographer(String l, String r, String p, String u) {
	    left = l;
	    right = r;
	    paid = p;
	    utterances = u;
	}

	public void setLC(String l) { left = l; }
	public void setRC(String r) { right = r; }
	public void setPaid(String p) { paid = p; }
	public void setU(String u) { utterances = u; }


	public String getLC() { return left; }
	public String getRC() { return right; }
	public String getPaid() { return paid; }
	public String getUtterances() { return utterances; }

	public boolean hasPaid() { return (paid.equals("Y")); }

	public String toString() {
	    return left+right+paid+utterances;
	}
    }


    private Vector<Cryptographer> crypts;

    public String toString() {
	String result = "";

	boolean first = true;
	for (int i=0; i<crypts.size(); i++) {
	    if (!first) {
		result +=",";
	    }
	    result+=crypts.get(i).toString();
	    first = false;
	}
	return result;
    }
    
    public static void main(String[] args) throws Exception {
	if (args.length != 1) {
	    System.err.println("USAGE: $ java GenDinCrypt N");
	    System.err.println("(where N is a number > 2)");
	    System.exit(1);
	}

	int nCrypt = Integer.valueOf(args[0]);
	
	GenDinCrypt generator = new GenDinCrypt();
	generator.start(nCrypt);

    }

    public void start(int nCrypt) {
	
	crypts = new Vector<Cryptographer>();

	// The temporal relation
	List<String> RT = new ArrayList<String>();

	// Here we store the evaluation for who paid, from 0 to nCrypt (=company)
	// Each element is a list of states where the formula is true.
	Vector<List<String>> payer = new Vector<List<String>>();
	for (int i=0; i<=nCrypt; i++) {
	    payer.add(new ArrayList<String>());
	}

	// The states where odd is true
	List<String> oddStates = new ArrayList<String>();

	// The states where even is true
	List<String> evenStates = new ArrayList<String>();
	
	for (int i=0; i<nCrypt; i++) {
	    crypts.add(i,new Cryptographer("E","E","E","E"));
	}

	System.out.println("// This is a model automatically generated by GenDinCrypt with N = "+nCrypt);
	
	System.out.println("\n// Number of cryptographers:");
	System.out.println("N="+nCrypt+";");
	System.out.println("\n// Now we declare all the states. Let's start from the simple empty initial states");
	System.out.println("S0 = ("+this.toString()+");");
	System.out.println("\n// In the following step we generate all possible initial states");

	// The counter of global states
	int sCounter = 1;

	// i is for the possible distribution of coins	
	for (int i=0; i<Math.pow(2,nCrypt); i++) {

	    // j is for the payer (index nCrypt is for the company)
	    for (int j=0; j<=nCrypt; j++) {

		// And now we iterate over cryptographers: p is for place in vector
		String astate = "";

		// We treat the first cryptographer separately (he can see
		// coin 0 and coin n)
		Cryptographer crypto = crypts.get(0);

		if ( (i&((int)Math.pow(2,(nCrypt-1))))!=0 ) {
		    crypto.setRC("H");
		} else {
		    crypto.setRC("T");
		}
		if ( (i&1)!=0 ) {
		    crypto.setLC("H");
		} else {
		    crypto.setLC("T");
		}
		if ( j==0 ) {
		    crypto.setPaid("Y");
		}
		else {
		    crypto.setPaid("N");
		}
		astate += crypto.toString();

		// And now all the other cryptographers
		for (int p=1; p<nCrypt; p++ ) {
		    
		    crypto = crypts.get(p);
		    
		    if ( (i&((int)Math.pow(2,p-1)))!=0 ) {
			crypto.setRC("H");
		    } else {
			crypto.setRC("T");
		    }
		    
		    if ( (i&((int)Math.pow(2,p)))!=0 ) {
			crypto.setLC("H");
		    } else {
			crypto.setLC("T");
		    }
		    if ( j==p ) {
			crypto.setPaid("Y");
		    }
		    else {
			crypto.setPaid("N");
		    }
		    astate = astate + "," + crypto.toString();
		} // end for loop over cryptographers

		// OK now the state is ready to be processed
		System.out.println("S"+sCounter+" = ("+astate+");");

		// We add a transition from the initial state
		RT.add("(S0,S"+sCounter+")");

		// We populate the atoms
		boolean companyPaid = true;
		for (int cCounter = 0; cCounter < crypts.size(); cCounter++ ) {
		    if (crypts.get(cCounter).hasPaid()) {
			payer.get(cCounter).add("S"+sCounter);
			companyPaid = false;
		    }
		}
		if (companyPaid) {
		    payer.get(nCrypt).add("S"+sCounter);
		}
		
		// We increase the counter and we compute the successor
		sCounter++;
		int oddUtterances = 0;
		for (int cCounter = 0; cCounter < crypts.size(); cCounter++ ) {
		    crypto = crypts.get(cCounter);
		    if (!(crypto.getLC().equals(crypto.getRC())) & (!crypto.hasPaid())) {
			oddUtterances++;
		    }
		}
		String parity = "V"; // Even
		if ( (oddUtterances % 2)==1 ) {
		    // odd number of utterances
		    parity = "O";
		} 
		// Set parity for each cryptographer:
		for (int cCounter = 0; cCounter < crypts.size(); cCounter++ ) {
		    crypts.get(cCounter).setU(parity);
		}

		// Now we build the string, first crypto 0 then the others:
		String aState = crypts.get(0).toString();
		for (int cCounter = 1; cCounter < crypts.size(); cCounter++ ) {
		    aState = aState + ","+crypts.get(cCounter).toString();
		}
		// We print the new state
		System.out.println("S"+sCounter+" = ("+aState+");");

		// We add the state to the temporal relation
		RT.add("(S"+(sCounter-1)+",S"+sCounter+")");
		// And we also add a self loop at the end:
		RT.add("(S"+sCounter+",S"+sCounter+")");

		// We populate the atoms
		// First who paid
		companyPaid = true;
		for (int cCounter = 0; cCounter < crypts.size(); cCounter++ ) {
		    if (crypts.get(cCounter).hasPaid()) {
			payer.get(cCounter).add("S"+sCounter);
			companyPaid = false;
		    }
		}
		if (companyPaid) {
		    payer.get(nCrypt).add("S"+sCounter);
		}

		if ( parity.equals("V") ) {
		    // an even state
		    evenStates.add("S"+sCounter);
		}
		if ( parity.equals("O") ) {
		    // an odd state
		    oddStates.add("S"+sCounter);
		}

		
		// And now we put everything back to normal and increase the counter
		for (int cCounter = 0; cCounter < crypts.size(); cCounter++ ) {
		    crypts.get(cCounter).setU("E");
		}
		sCounter++;
		
	    } //end for loop over payers
	} // end for loop over possible coins combinations


	// Printing the temporal relation:
	System.out.print("RT = { ");
	boolean firstTime = true;
	for (String trans: RT) {
	    if (!firstTime) {
		System.out.print(","+trans);
	    } else {
		System.out.print(trans);
	    }
	    firstTime = false;
	}
	System.out.println(" };");

	// Printing the atoms for who paid (cryptographers):	
	for (int cCounter = 0; cCounter < crypts.size(); cCounter++ ) {
	    firstTime = true;
	    System.out.print("crypt_"+(cCounter+1)+"_paid = { ");
	    for (String aState: payer.get(cCounter)) {		
		if (firstTime) {
		    System.out.print(aState);
		} else {
		    System.out.print(","+aState);
		}
		firstTime = false;
	    }
	    System.out.println(" };");
	}

	// Printing atom for when company paid
	firstTime = true;
	System.out.print("company_paid = { ");
	for (String aState: payer.get(nCrypt)) {		
	    if (firstTime) {
		System.out.print(aState);
	    } else {
		System.out.print(","+aState);
	    }
	    firstTime = false;
	}
	System.out.println(" };");

	// Printing the atoms for even and odd:
	firstTime = true;
	System.out.print("odd = { ");
	for (String aState: oddStates) {		
	    if (firstTime) {
		System.out.print(aState);
	    } else {
		System.out.print(","+aState);
	    }
	    firstTime = false;
	}
	System.out.println(" };");

	firstTime = true;
	System.out.print("even = { ");
	for (String aState: evenStates) {		
	    if (firstTime) {
		System.out.print(aState);
	    } else {
		System.out.print(","+aState);
	    }
	    firstTime = false;
	}
	System.out.println(" };");


    }

}

	
			      
